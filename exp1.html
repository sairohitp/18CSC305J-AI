<!DOCTYPE html>
<html>
<head>
<style>
* {
line-height: 1.5;
}
h2 {
text-align: center;
}
body {
width: 800px;
margin: 0 auto;
}
pre{
background-color: #f0f0f0;
padding: 10px;
border-radius: 5px;
}
footer {
display: flex;
justify-content: space-between;
}
</style>
</head>
<body>
<a href = "index.html"><h2>18CSC305J - Artificial Intelligence</h2></a>
<h3>Experiment 1 - Implementation of Toy Problem (N Queens)</h3>
<h4>Algorithm</h4>
<p>
Start in the leftmost column<br>
If all queens are placed return true<br>
Try all rows in the current column. Do the following for every row.<br>
If the queen can be placed safely in this row<br>
Then mark this [row, column] as part of the solution and recursively check if placing queen here leads to a solution.<br>
If placing the queen in [row, column] leads to a solution then return true.<br>
If placing queen doesnâ€™t lead to a solution then unmark this [row, column] then backtrack and try other rows.<br>
If all rows have been tried and valid solution is not found return false to trigger backtracking.<br>
</p>
<h4>Code</h4>
<pre>
# Python3 program to solve N Queen
# Problem using backtracking

global N
N = 4


def printSolution(board):
	for i in range(N):
		for j in range(N):
			if board[i][j] == 1:
				print("Q",end=" ")
			else:
				print(".",end=" ")
		print()


# A utility function to check if a queen can
# be placed on board[row][col]. Note that this
# function is called when "col" queens are
# already placed in columns from 0 to col -1.
# So we need to check only left side for
# attacking queens
def isSafe(board, row, col):

	# Check this row on left side
	for i in range(col):
		if board[row][i] == 1:
			return False

	# Check upper diagonal on left side
	for i, j in zip(range(row, -1, -1),
					range(col, -1, -1)):
		if board[i][j] == 1:
			return False

	# Check lower diagonal on left side
	for i, j in zip(range(row, N, 1),
					range(col, -1, -1)):
		if board[i][j] == 1:
			return False

	return True


def solveNQUtil(board, col):

	# Base case: If all queens are placed
	# then return true
	if col >= N:
		return True

	# Consider this column and try placing
	# this queen in all rows one by one
	for i in range(N):

		if isSafe(board, i, col):

			# Place this queen in board[i][col]
			board[i][col] = 1

			# Recur to place rest of the queens
			if solveNQUtil(board, col + 1) == True:
				return True

			# If placing queen in board[i][col
			# doesn't lead to a solution, then
			# queen from board[i][col]
			board[i][col] = 0

	# If the queen can not be placed in any row in
	# this column col then return false
	return False


# This function solves the N Queen problem using
# Backtracking. It mainly uses solveNQUtil() to
# solve the problem. It returns false if queens
# cannot be placed, otherwise return true and
# placement of queens in the form of 1s.
# note that there may be more than one
# solutions, this function prints one of the
# feasible solutions.
def solveNQ():
	board = [[0, 0, 0, 0],
			[0, 0, 0, 0],
			[0, 0, 0, 0],
			[0, 0, 0, 0]]

	if solveNQUtil(board, 0) == False:
		print("Solution does not exist")
		return False

	printSolution(board)
	return True


# Driver Code
if __name__ == '__main__':
	solveNQ()
</pre>

<<<<<<< HEAD
<h4>Output</h4>
<pre>
=======
	<h4>Output</h4>
	<pre>
>>>>>>> origin/main
. . Q . 
Q . . . 
. . . Q 
. Q . . 
</pre>
<<<<<<< HEAD
<footer>
<div></div>
<div><a href = "exp2.html"><p>Experiment 2&rarr;</p></a></div>
</footer>
</body>
=======
	<footer>
		<div></div>
		<div><a href="exp2.html">
				<p>Experiment 2&rarr;</p>
			</a></div>
	</footer>
</body>

>>>>>>> origin/main
</html>